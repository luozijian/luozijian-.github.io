<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[craking the code interview 第五版 C语言实现]]></title>
    <url>%2F2017%2F06%2F01%2Fcraking%20the%20code%20interview%20%E7%AC%AC%E4%BA%94%E7%89%88%20C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 面试考题本篇为学习笔记，题目出自 craking the code interview，中文译名 程序员面试经典（第五版），用 C/C++ 实现 一. 字符串与数组1. 确定字符互异 题目描述： 请实现一个算法，确定一个字符串的所有字符是否全都不同。这里我们要求不允许使用额外的存储结构。 给定一个string iniString，请返回一个bool值,True代表所有字符全都不同，False代表存在相同的字符。保证字符串中的字符为ASCII字符。字符串的长度小于等于3000。 测试样例： 123&gt; &quot;aeiou&quot; 返回：True&gt; &quot;BarackObama&quot; 返回：False&gt; 较差的实现方式： 1234567891011121314151617181920class Different &#123;public: bool checkDifferent(string iniString) &#123; // write code here if(iniString.length() == 0 || iniString.length() &gt; 256)&#123; return false; &#125; for(int i = 0;i &lt; iniString.length() - 1;i++)&#123; //长度-1是因为最后一个元素不需要比较，前面已经比较过了 for(int j = i + 1;j &lt; iniString.length();j++)&#123; if(iniString[i] == iniString[j])&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;; 较优的实现方式： 123456789101112131415161718192021class Different &#123;public: bool checkDifferent(string iniString) &#123; // write code here if(iniString.length() == 0 || iniString.length() &gt; 256)&#123; return false; &#125; bool b[256] = &#123;true&#125;;//C++里面要先赋值，否则会提示数组越界 for(int i = 0;i &lt; iniString.length();i++)&#123; int c = iniString[i]; if(b[c] == true)&#123; return false; &#125; b[c] = true;//出现过一次的数设为true，第二次一旦出现则返回false &#125; return true; &#125;&#125;; 2. 原串翻转 题目描述： 请实现一个算法，在不使用额外数据结构和储存空间的情况下，翻转一个给定的字符串(可以使用单个过程变量)。 给定一个string iniString，请返回一个string，为翻转后的字符串。保证字符串的长度小于等于5000。 测试样例： 123&gt; &quot;This is nowcoder&quot;&gt; 返回：&quot;redocwon si sihT&quot;&gt; 1234567891011121314151617class Reverse &#123;public: string reverseString(string iniString) &#123; // write code here int start = 0; int end = iniString.length() - 1; char tmp; while(start &lt; end)&#123; tmp = iniString[start]; iniString[start++] = iniString[end]; iniString[end--] = tmp; &#125; return iniString; &#125;&#125;; 3. 确定两串乱序同构 题目描述 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。这里规定大小写为不同字符，且考虑字符串重点空格。 给定一个string stringA和一个string stringB，请返回一个bool，代表两串是否重新排列后可相同。保证两串的长度都小于等于5000。 测试样例： 12345&gt; &quot;This is nowcoder&quot;,&quot;is This nowcoder&quot;&gt; 返回：true&gt; &quot;Here you are&quot;,&quot;Are you here&quot;&gt; 返回：false&gt; &gt; 12345678910111213141516class Same &#123;public: bool checkSam(string stringA, string stringB) &#123; // write code here if(stringA.length() != stringB.length())&#123; return false; &#125; sort(stringA.begin(),stringA.end()); sort(stringB.begin(),stringB.end()); if (stringA == stringB) return true; return false; &#125;&#125;; 4. 空格替换 题目描述 请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。 给定一个string iniString 为原始的串，以及串的长度 int len, 返回替换后的string。 测试样例： 12345&gt; &quot;Mr John Smith”,13&gt; 返回：&quot;Mr%20John%20Smith&quot;&gt; ”Hello World”,12&gt; 返回：”Hello%20%20World”&gt; &gt; 12345678910111213141516class Replacement &#123;public: string replaceSpace(string iniString, int length) &#123; // write code here string str=""; for(int i=0; i&lt;length; i++)&#123; if(iniString[i]==' ')&#123; str += string("%20"); &#125; else&#123; str += iniString[i]; &#125; &#125; return str; &#125;&#125;; 5. 基本字符串压缩 题目描述 利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串“aabcccccaaa”经压缩会变成“a2b1c5a3”。若压缩后的字符串没有变短，则返回原先的字符串。 给定一个string iniString为待压缩的串(长度小于等于10000)，保证串内字符均由大小写英文字母组成，返回一个string，为所求的压缩后或未变化的串。 测试样例 12345&gt; &quot;aabcccccaaa&quot;&gt; 返回：&quot;a2b1c5a3&quot;&gt; &quot;welcometonowcoderrrrr&quot;&gt; 返回：&quot;welcometonowcoderrrrr&quot;&gt; &gt; 12345678910111213141516171819202122232425262728class Zipper &#123;public: string zipString(string iniString) &#123; // write code here string myStr; int count = 1,i; char last = iniString[0];//最后一个不同的字符 for(i = 1;i &lt; iniString.length();i++)&#123; if(last == iniString[i])&#123; count++; &#125;else&#123; myStr += last + to_string(count); last = iniString[i]; count = 1; &#125; &#125; string res = myStr + last + to_string(count); if(res.length() &gt;= iniString.length())&#123; return iniString; &#125; return res; &#125;&#125;; 6. 像素翻转 题目描述 有一副由NxN矩阵表示的图像，这里每个像素用一个int表示，请编写一个算法，在不占用额外内存空间的情况下(即不使用缓存矩阵)，将图像顺时针旋转90度。 给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵,保证N小于等于500，图像元素小于等于256。 测试样例： 123&gt; [[1,2,3],[4,5,6],[7,8,9]],3&gt; 返回：[[7,4,1],[8,5,2],[9,6,3]]&gt; 7. 清除行列 题目描述 请编写一个算法，若N阶方阵中某个元素为0，则将其所在的行与列清零。 给定一个N阶方阵int[][](C++中为vector&gt;)mat和矩阵的阶数n，请返回完成操作后的int[][]方阵(C++中为vector&gt;)，保证n小于等于300，矩阵中的元素为int范围内。 测试样例： 123&gt; [[1,2,3],[0,1,2],[0,0,1]]&gt; 返回：[[0,0,3],[0,0,0],[0,0,0]]&gt; 123456789101112131415161718192021222324252627class Clearer &#123;public: vector&lt;vector&lt;int&gt; &gt; clearZero(vector&lt;vector&lt;int&gt; &gt; mat, int n) &#123; // write code here vector&lt;bool&gt; row(n,false); vector&lt;bool&gt; column(n,false); for(int i =0;i &lt; n;i++)&#123; for(int j = 0;j &lt; n;j++)&#123; if(mat[i][j] == 0)&#123; row[i] = true; column[j] = true; &#125; &#125; &#125; for(int i = 0;i &lt; n;i++)&#123; for(int j = 0;j &lt; n;j++)&#123; if(row[i] || column[j])&#123; mat[i][j] = 0; &#125; &#125; &#125; return mat; &#125;&#125;; 8. 翻转子串 题目描述 假定我们都知道非常高效的算法来检查一个单词是否为其他字符串的子串。请将这个算法编写成一个函数，给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成，要求只能调用一次检查子串的函数。 给定两个字符串s1,s2,请返回bool值代表s2是否由s1旋转而成。字符串中字符为英文字母和空格，区分大小写，字符串长度小于等于1000。 测试样例： 12345&gt; &quot;Hello world&quot;,&quot;worldhello &quot;&gt; 返回：false&gt; &quot;waterbottle&quot;,&quot;erbottlewat&quot;&gt; 返回：true&gt; 1234567891011121314151617class ReverseEqual &#123;public: bool checkReverseEqual(string s1, string s2) &#123; // write code here if(s1.length() != s2.length())&#123; return false; &#125; string s1s1 = s1 + s1; if(s1s1.find(s2) == -1)&#123; //原理:s2(旋转后的串) 一定是 s1(原串) ＋ s1 的子串,否则 s2 不能由 s1 旋转而来 return false; &#125; return true; &#125;&#125;; 二、链表1. 链表中倒数第 k 个结点 题目描述 输入一个链表，输出该链表中倒数第k个结点。 1234567891011121314151617181920212223242526272829303132333435363738394041/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; if(pListHead == NULL)&#123; return NULL; &#125; //双指针 ListNode *p1 = pListHead; ListNode *p2 = pListHead; for(int i = 1;i &lt;= k - 1;i++)&#123; //p2先向前移动k位 if(p2 == NULL)&#123; return NULL; &#125; p2 = p2-&gt;next; &#125; if(p2 == NULL)&#123; return NULL; &#125; while(p2-&gt;next != NULL)&#123; //p1 p2同时移动，当p2到达 p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; return p1; &#125;&#125;; 2. 访问单个节点的删除 题目描述 实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。 给定带删除的节点，请执行删除操作，若该节点为尾节点，返回false，否则返回true 1234567891011121314151617181920212223/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;*/class Remove &#123;public: bool removeNode(ListNode* pNode) &#123; // write code here if(!pNode || !pNode-&gt;next)&#123; return false; &#125; ListNode* p = pNode-&gt;next; pNode-&gt;val = p-&gt;val; pNode-&gt;next = p-&gt;next; return true; &#125;&#125;; 3. 链表分割 题目描述 编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前 给定一个链表的头指针 ListNode *pHead，请返回重新排列后的链表的头指针。注意：分割以后保持原来的数据顺序不变。 12345678910111213141516171819202122232425262728293031323334/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;*/class Partition &#123;public: ListNode* partition(ListNode* pHead, int x) &#123; // write code here if(pHead == nullptr)&#123; return nullptr; &#125; ListNode *smallList = new ListNode(-1); ListNode *bigList = new ListNode(-1); ListNode *ps = smallList,*pb = bigList,*cur = pHead; while(cur)&#123; if(cur-&gt;val &lt; x)&#123; ps-&gt;next = cur; ps = cur; &#125;//if else&#123; pb-&gt;next = cur; pb = cur; &#125;//else cur = cur-&gt;next; &#125;//while pb-&gt;next = nullptr; ps-&gt;next = bigList-&gt;next; return smallList-&gt;next; &#125;&#125;; 4. 链式A+B 题目描述 有两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表的首部。编写函数对这两个整数求和，并用链表形式返回结果。 给定两个链表ListNode A，ListNode B，请返回A+B的结果(ListNode*)。 测试样例： 123&gt; &#123;1,2,3&#125;,&#123;3,2,1&#125;&gt; 返回：&#123;4,4,4&#125;&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;*/class Plus &#123;public: ListNode* plusAB(ListNode* a, ListNode* b) &#123; // write code here if(a == nullptr || b == nullptr)&#123; return false; &#125; ListNode* head = new ListNode(-1);//创建一个空链表 ListNode* p = head;//创建p指针指向head ListNode* pa = a; ListNode* pb = b; ListNode* node = nullptr;//声明存放结果节点的变量，初值为空 int c = 0,sum,val1,val2;//声明 进位、和、值1、值2 while(pa != nullptr || pb != nullptr || c != 0)&#123; val1 = pa == nullptr ? 0 : pa-&gt;val; val2 = pb == nullptr ? 0 : pb-&gt;val; sum = val1 + val2 + c; c = sum / 10; node = new ListNode(sum%10);//创建链表，值为当前位结果值 //尾插法 p-&gt;next = node;//给head创建后继节点 p = node;//p移动到node pa = pa == nullptr ? nullptr : pa-&gt;next; pb = pb == nullptr ? nullptr : pb-&gt;next; &#125; return head-&gt;next; &#125;&#125;; 5. 回文链表 题目描述 请编写一个函数，检查链表是否为回文。 给定一个链表ListNode *pHead，请返回一个bool，代表链表是否为回文。 测试样例： 12345&gt; &#123;1,2,3,2,1&#125;&gt; 返回：true&gt; &#123;1,2,3,2,3&#125;&gt; 返回：false&gt; 12]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 GitHub Pages + Hexo 免服务器搭建个人博客]]></title>
    <url>%2F2017%2F05%2F31%2F%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20%2B%20Hexo%20%E5%85%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[废话不说，先上图 背景很久之前就想搭建一个属于自己的博客，也有人推荐用 WordPress 啥的，但是之前也一直抽不出时间来弄，最近参加的比赛暂时过了校赛，闲暇之余，就想起来把博客整一整啦 GitHub Pages 是什么GitHub Pages 是通过在 GitHub 网站托管和发布的公开网页，因此是不需要我们搭建服务器的 Hexo 是什么Hexo 是一个用来生成静态界面的框架，使用 Hexo，你就可以直接使用 Markdown 来写文章，而不用关心前端样式的展现，想深入研究的同学可以通过 传送门 查看官方中文文档。 注册 GitHub 并初始化一个 GitHub Pages 的仓库注册就不多说啦，GitHub Pages 的仓库搭建官方文档也说的很明白了，这里就不赘述了，小伙伴可以移步 GitHub Pages 官方文档 克隆项目仓库到本地git clone git@github.com:your username/your username.github.io.git 准备工作安装 Hexo 之前需要安装 Git，Node.js，npm，还没安装的小伙伴请 查看安装教程 安装 Hexo 进入到你的本地项目文件目录（路径替换成你的项目路径哦） 1cd /Code/luozijian.github.io 下载并安装 Hexo 1npm install hexo-cli -g 若出现如图所示内容，则表示安装成功 配置 Hexo 初始化博客 123456// 建立一个文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字$ hexo init &lt;folder&gt;// 进入博客文件夹，&lt;folder&gt;为文件夹的名称$ cd &lt;folder&gt;// node.js的命令，根据博客既定的dependencies配置安装所有的依赖包$ npm install 配置博客 1vi _config.yml 配置基本信息 123456title: 这是标题subtitle: 这是副标题description: 这是描述author: 作者随便填language: zh-CNtimezone: Asia/Shanghai 配置个人域名 1url: http://你的域名 部署 GitHub 注意要部署 GitHub 要先跑这个命令 npm install hexo-deployer-git --save 1234deploy: type: git repo: git@github.com:your username/your username.github.io.git branch: master 发布简单的一条命令就可以发布到 GitHub Pages 啦，注意每次修改你的博客后都要记得发布哦～1hexo g -d 使用阿里云自定义域名 来到阿里云的 域名解析控制台，选择添加解析 添加一个 blog 的子域名，然后保存 来到你的 GitHub Pages 在仓库点击 Setting 选择自定义域名，填写你的阿里云域名，点击 save 按钮 为了防止你每次使用 hexo g -d 布到 GitHub Pages 的时候会覆盖掉你的自定义域名设置（步骤四），因为要在本地 source 目录 新建一个 CNAME 文件，无后缀，如图，然后在 CNAME 文件里面写上需要绑定的域名即可（仅域名，不要http） 最后我的博客，想自己搞博客的同学可以搞起啦，不喜欢默认的主题的话还可以去 Hexo 主题 找找自己喜欢的主题哦，如果还有什么问题欢迎在下面评论哦~]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 自带SMTP配置邮件服务]]></title>
    <url>%2F2017%2F05%2F31%2FLaravel%20%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[开启邮箱服务 要使用邮箱服务就必须开启邮箱的 POP3 服务和 SMTP 服务，本教程演示 QQ邮箱的配置 登录你的 QQ邮箱，来到 设置-&gt;账户，开启下图中的服务 记录下生成的授权码！记录下生成的授权码！记录下生成的授权码！重要的事情说三遍！ 配置 修改 .env 文件，复制以下内容进去 123456MAIL_DRIVER="smtp" //邮件发送驱动MAIL_HOST="smtp.qq.com" //邮箱所在主机，比如网易邮箱是 smpt.163.comMAIL_PORT=25 //邮箱发送服务端口号，比如一般默认值是25，但如果设置SMTP使用SSL加密，该值为465MAIL_USERNAME=123456@qq.com //邮箱账号MAIL_PASSWORD=abcdefg //刚刚生成的授权码MAIL_ENCRYPTION=tls //加密类型，可以设置为null表示不使用任何加密，也可以设置为tls或ssl 修改 config/mail.php 文件 1234'from' =&gt; [ 'address' =&gt; '123456@qq.com', //用来发送邮件的邮箱 'name' =&gt; '', //发送邮件使用的用户名], 创建邮件模板在 resources/emails 创建一个模板文件 test.blade.php，并复制以下内容进去 1&#123;&#123; $data['test1'] &#125;&#125; 这是测试 &#123;&#123; $data['test2'] &#125;&#125;。 发送邮件 在 app/helpers.php 添加以下内容 1234function sendMail($email,$data,$view)&#123; Mail::send('emails.'.$view,['data'=&gt;$data],function($message)use($email)&#123; $message-&gt;to($email)-&gt;subject('【这是邮件标题】');; &#125;); 在你需要调用发送邮件的方法的地方添加以下代码 1234567$email = '123456@qq.com'; //接受邮件的邮箱$tempData = [ 'test1' =&gt; 'hello', //邮件模板变量，自定 'test2' =&gt; 'world',];$view = 'test'; //要使用的模板，比如这里的是刚刚创建的模板 test.blade.phpsendMail($email,$tempData,$view); 邮件还支持 延时发送，添加附件，添加图片 的功能，这里就不展开了，详情可以参考官方文档 文档 laravel 邮件发送 官方文档：http://d.laravel-china.org/docs/5.3/mail]]></content>
      <categories>
        <category>Laravel 学习笔记</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPStorm 实现单步跟踪]]></title>
    <url>%2F2017%2F05%2F25%2FPHPStorm%20%E5%AE%9E%E7%8E%B0%E5%8D%95%E6%AD%A5%E8%B7%9F%E8%B8%AA%2F</url>
    <content type="text"><![CDATA[最近和小伙伴志平在做一个比赛项目，主要用 PHP 来实现，其中有用到比较复杂的算法（多目标优化），今晚算法出了问题 :sweat:，志平希望能够像大一用 Visual Studio 那样 单步跟踪 的调试，于是我今晚尝试了一下，在 PHPStorm 里配置 单步跟踪。 环境 Homestead PHPStorm2017 PHP7.0 Chrome Homestead中配置Xdebug 使用 vagrant up 启动你的 Homestead 命令行下 sudo vi /etc/php/7.0/fpm/conf.d/20-xdebug.ini (注意你的 php 版本和对应的文件夹) 复制以下内容进去 1234567zend_extension=xdebug.soxdebug.remote_enable = 1xdebug.remote_connect_back = 1xdebug.remote_port = 9000xdebug.scream=0 xdebug.cli_color=1xdebug.show_local_vars=1 保存这个文件（如果这个文件不存在的话，这样建立一个软连接过来 sudo ln -s /etc/php/7.0/mods-available/xdebug.ini /etc/php/7.0/fpm/conf.d/20-xdebug.ini ），如果你还不明白软连接，可以参考 软连接 重启 php7.0-fpm ：sudo service php7.0-fpm restart Chorme中安装Xdebug helper 安装chrome扩展 Xdebug helper 进入 Xdebug hepler 的配置选项中，选择 IDE key 为 PHPStorm 把扩展调整为 debug 模式，如图 配置你的PHPStorm 打开你的 PHPStorm 并设置一个测试断点。如图 打开 PHPStorm 中的 右上角小电话，即可开始监听断点。如图 最后设置一些你的项目目录，就是你的项目目录对应你映射到 Homestead 的目录 在 PHPStorm 右上角选择刚刚新建的 Server，如图 配置你的 Server （比如你想从哪个url开始跟踪） 点击 PHPStorm 右上角小甲虫，你就会发现弹出了个对话框并且已经开始调试了 最后 好了，如果你看到这里，你的 PHPStorm 应该已经有了 单步跟踪 的新功能啦～，让我们来看下效果，如图 ​就是这么简单的操作～，想要随时随地调试你的页面的小伙伴搞起来啦～。突然想起今天志平要的接口还没完成 :sweat_smile: ，管他呢，睡个好觉先。]]></content>
      <categories>
        <category>IDE 配置</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Larval-sms + 阿里大鱼 配置定时发送短信服务]]></title>
    <url>%2F2017%2F05%2F25%2FLaravel-sms%20%E9%85%8D%E7%BD%AE%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[安装 引入依赖 1composer require toplan/laravel-sms:~2.6 参数配置 在config/app.php文件中providers数组里加入： 12Toplan\PhpSms\PhpSmsServiceProvider::class,Toplan\Sms\SmsManagerServiceProvider::class, 在config/app.php文件中的aliases数组里加入： 12'PhpSms' =&gt; Toplan\PhpSms\Facades\Sms::class,'SmsManager' =&gt; Toplan\Sms\Facades\SmsManager::class, 配置 修改 config/phpsms.php 123scheme' =&gt; [ 'Alidayu',//配置代理器为阿里大鱼], 修改 app/helpers.php ，复制以下内容进去 123456function sendMessage($mobile,$template_id,$tempData)&#123; $templates = [ 'Alidayu' =&gt; $template_id//模板id ]; Toplan\PhpSms\Sms::make()-&gt;to($mobile)-&gt;template($templates)-&gt;data($tempData)-&gt;send();&#125; Artisan 命令行 生成命令 1php artisan make:command SendMessage 配置命令 刚才生成的 Artisan 命令行 文件在 app/Console/Commands 目录，我们修改目录下刚刚生成的的 SendMessage.php 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace App\Console\Commands;use Illuminate\Console\Command;class SendMessage extends Command&#123; /** * The name and signature of the console command. * * @var string */ protected $signature = 'message:send';//命令的格式，比如这里命令就是 php artisan message:send /** * The console command description. * * @var string */ protected $description = 'Send message to user';//命令的描述 /** * Create a new command instance. * * @return void */ public function __construct() &#123; parent::__construct(); &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; //这里处理你的业务逻辑 $mobile = 11111111111;//要发送的手机号 template_id ＝ 111111;//你的阿里大鱼模板id $tempData = [ 'name' =&gt; '123',//模板变量自定 ]; sendMessage($mobile,$template_id,$tempData); &#125;&#125; 注册命令 修改 app/Console/Kernel.php 文件，添加以下内容 123protected $commands = [ Commands\SendMessage::class,]; 确认命令正确生成和配置 使用 php artisan list 命令，如果能看到 php artisan message:send 说明配置成功 定时任务在你的服务器（linux）使用 crontab -e，添加以下内容 1* * 1 * * cd 你的项目根目录 &amp;&amp; php artisan message:send 这是每天执行一次的定时任务，如果你还不明白定时任务怎么使用，请查看 定时任务用法例子 Debug为了方便我们排查错误，我们在数据库创建一个日志表 laravel-sms 创建 migration 文件 1php artisan make:migration create_sms_table --create 复制以下内容进去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpuse Illuminate\Database\Migrations\Migration;use Illuminate\Database\Schema\Blueprint;class CreateSmsTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::create('laravel_sms', function (Blueprint $table) &#123; $table-&gt;increments('id'); //to:用于存储手机号 $table-&gt;string('to')-&gt;default(''); //temp_id:存储模板标记，用于存储任何第三方服务商提供的短信模板标记/id $table-&gt;string('temp_id')-&gt;default(''); //data:模板短信的模板数据，建议json格式 $table-&gt;string('data')-&gt;default(''); //content:内容 $table-&gt;string('content')-&gt;default(''); //voice_code:语言验证码code $table-&gt;string('voice_code')-&gt;default(''); //发送失败次数 $table-&gt;mediumInteger('fail_times')-&gt;default(0); //最后一次发送失败时间 $table-&gt;integer('last_fail_time')-&gt;unsigned()-&gt;default(0); //发送成功时的时间 $table-&gt;integer('sent_time')-&gt;unsigned()-&gt;default(0); //代理器使用日志，记录每个代理器的发送状态，可用于排错 $table-&gt;text('result_info')-&gt;nullable(); $table-&gt;timestamps(); $table-&gt;softDeletes(); $table-&gt;engine = 'InnoDB'; //说明 //1：temp_id和data用于发送模板短信。 //2：content用于直接发送短信内容，不使用模板。 //3：voice_code用于存储语言验证码code。 &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::dropIfExists('laravel_sms'); &#125;&#125; 迁移数据库 php artisan migrate 这样我们就可以很方便的查看日志来排查错误啦 其他 laravel-sms 官方文档：https://github.com/toplan/laravel-smsphp-sms 官方文档：https://github.com/toplan/phpsmsArtisan 命令行官方文档：http://d.laravel-china.org/docs/5.3/artisan#registering-commands]]></content>
      <categories>
        <category>Laravel 学习笔记</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 常见问题汇总]]></title>
    <url>%2F2017%2F05%2F21%2FLaravel%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言作为一个 Laravel 开发者，在部署 Laravel 项目的时候总是会遇到这样那样奇怪的问题，每次遇到都要去 Google，实在是有点麻烦，就想自己整理一篇文章来记录这些常见的问题。 常见问题一：Specified key was too long 在开发 Laravel 的项目时，有时我们需要对数据库进行迁移，可是当我们在别的环境下跑 php artisan migrate 的时候经常会出现以下报错： 12345[Illuminate\Database\QueryException]SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes (SQL: alter table users add unique users_email_unique (email))[PDOException]SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes 这时候我们把下面的代码添加到 AppServiceProvider.php 12345use Illuminate\Support\Facades\Schema;public function boot()&#123; Schema::defaultStringLength(191);&#125; 常见问题二： This cache store does not support tagging有时候我们在项目跑的好好的，突然使用 php artisan migrate 就会出现这个错误。 准确的说，这不是一个bug，详情可以参考 这里，这是由于使用了 entrust 权限管理包导致，解决的话只需要修改 .env 文件，把 CACHE_DRIVER 改成 array 就可以啦。 常见问题三：The only supported ciphers are xxx and xxx with the correct key lengths这时候先确认你的 .env 文件是否存在，如果没有则创建，如果 .env 文件已经存在，则跑 php artisan key:generate 命令即可]]></content>
      <categories>
        <category>Laravel 学习笔记</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置 MySQL 远程连接]]></title>
    <url>%2F2017%2F05%2F17%2F%E9%85%8D%E7%BD%AE%20MySQL%20%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[配置打开 iptables 3306端口 如果你是 CentOS 系列 12iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPTservice iptables save #保存iptables规则 如果你是 Ubuntu/Debian 系列 12iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPTiptables-save &gt; /etc/iptables.up.rules #保存iptables规则 创建用户 登录你的远程服务器 1ssh root@your domain.com 登录 MySQL 1mysql -u root -p 创建用户（用户名不能是root） 1create user 用户名 identified by '密码'; 授权用户 MySQL 5.7 1grant all on 数据库名.* to 用户名 MySQL 5.6 1grant all privileges on 数据库名.* to 用户名@’%’ identified by ‘用户密码’; 如果出现 ERROR 1524 (HY000): Plugin ‘*9E53930467B20A15727780FB02007B379CE21A84’ is not loaded 尝试删除用户在重复以上步骤]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>